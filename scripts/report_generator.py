import pandas as pd
import numpy as np
from datetime import datetime, timedelta
from typing import Dict, List, Any
import json
import os
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart

class ReportGenerator:
    """Automated report generation and email system"""
    
    def __init__(self):
        self.report_history_file = "report_history.json"
        self.email_config = {
            'smtp_server': 'smtp.gmail.com',  # Placeholder
            'smtp_port': 587,
            'username': 'toxicgas.monitor@company.com',  # Placeholder
            'password': 'app_password'  # Placeholder
        }
    
    def generate_daily_report(self, current_data: Dict, historical_data: pd.DataFrame, alert_history: List[Dict]) -> str:
        """Generate comprehensive daily pollution report"""
        report_date = datetime.now().strftime("%Y-%m-%d")
        
        # Calculate statistics
        stats = self._calculate_daily_statistics(historical_data)
        
        # Generate report content
        report = f"""
# Daily Pollution Monitoring Report
**Date:** {report_date}
**Generated:** {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}

---

## Executive Summary

### Current Status
- **COâ‚‚ Level:** {current_data.get('co2', 0):.1f} ppm
- **NOâ‚‚ Level:** {current_data.get('no2', 0):.1f} Âµg/mÂ³
- **SOâ‚‚ Level:** {current_data.get('so2', 0):.1f} Âµg/mÂ³

### 24-Hour Statistics
"""
        
        # Add statistics for each gas
        for gas in ['co2', 'no2', 'so2']:
            if gas in stats:
                unit = 'ppm' if gas == 'co2' else 'Âµg/mÂ³'
                report += f"""
#### {gas.upper()} Statistics
- **Average:** {stats[gas]['mean']:.1f} {unit}
- **Maximum:** {stats[gas]['max']:.1f} {unit}
- **Minimum:** {stats[gas]['min']:.1f} {unit}
- **Standard Deviation:** {stats[gas]['std']:.1f} {unit}
"""
        
        # Compliance status
        compliance_score = self._calculate_compliance_score(stats)
        compliance_status = "âœ… COMPLIANT" if compliance_score >= 70 else "âŒ NON-COMPLIANT"
        
        report += f"""
---

## Compliance Status
**Overall Score:** {compliance_score}/100
**Status:** {compliance_status}

### Regulatory Thresholds
- **COâ‚‚:** 1000 ppm (Danger), 800 ppm (Warning)
- **NOâ‚‚:** 200 Âµg/mÂ³ (Danger), 100 Âµg/mÂ³ (Warning)
- **SOâ‚‚:** 500 Âµg/mÂ³ (Danger), 250 Âµg/mÂ³ (Warning)
"""
        
        # Alert summary
        report += f"""
---

## Alert Summary
**Total Alerts Today:** {len(alert_history)}
"""
        
        if alert_history:
            critical_alerts = [a for a in alert_history if a.get('severity') == 'critical']
            warning_alerts = [a for a in alert_history if a.get('severity') == 'warning']
            
            report += f"""
- **Critical Alerts:** {len(critical_alerts)}
- **Warning Alerts:** {len(warning_alerts)}

### Alert Details
"""
            for alert in alert_history[-5:]:  # Show last 5 alerts
                report += f"- **{alert.get('gas', 'Unknown').upper()}:** {alert.get('message', 'No message')} (Duration: {alert.get('duration_minutes', 0):.1f} min)\n"
        else:
            report += "- No alerts recorded today âœ…\n"
        
        # Recommendations
        recommendations = self._generate_recommendations(stats, alert_history)
        report += f"""
---

## Recommendations

{recommendations}
"""
        
        # Action log
        report += f"""
---

## Action Log
"""
        
        # This would be populated from actual action tracking
        report += "- Monitoring system operational\n"
        report += "- Data collection continuous\n"
        if alert_history:
            report += f"- {len(alert_history)} alerts processed\n"
        
        report += f"""
---

## Data Quality
- **Data Points Collected:** {len(historical_data)}
- **Data Completeness:** {self._calculate_data_completeness(historical_data):.1f}%
- **Last Update:** {datetime.now().strftime("%H:%M:%S")}

---

*This report was automatically generated by ToxicGas AI Monitor*
*For questions or concerns, contact: environmental@company.com*
"""
        
        # Save report to history
        self._save_report_to_history(report, report_date)
        
        return report
    
    def _calculate_daily_statistics(self, historical_data: pd.DataFrame) -> Dict:
        """Calculate daily statistics from historical data"""
        if historical_data.empty:
            return {}
        
        stats = {}
        for gas in ['co2', 'no2', 'so2']:
            if gas in historical_data.columns:
                stats[gas] = {
                    'mean': float(historical_data[gas].mean()),
                    'max': float(historical_data[gas].max()),
                    'min': float(historical_data[gas].min()),
                    'std': float(historical_data[gas].std())
                }
        
        return stats
    
    def _calculate_compliance_score(self, stats: Dict) -> int:
        """Calculate compliance score based on statistics"""
        if not stats:
            return 0
        
        score = 100
        
        # Thresholds for compliance
        thresholds = {
            'co2': {'warning': 800, 'danger': 1000},
            'no2': {'warning': 100, 'danger': 200},
            'so2': {'warning': 250, 'danger': 500}
        }
        
        for gas, gas_stats in stats.items():
            if gas in thresholds:
                avg_level = gas_stats['mean']
                max_level = gas_stats['max']
                
                # Deduct points for threshold violations
                if max_level > thresholds[gas]['danger']:
                    score -= 30
                elif max_level > thresholds[gas]['warning']:
                    score -= 15
                
                if avg_level > thresholds[gas]['warning']:
                    score -= 10
        
        return max(0, score)
    
    def _calculate_data_completeness(self, historical_data: pd.DataFrame) -> float:
        """Calculate data completeness percentage"""
        if historical_data.empty:
            return 0.0
        
        expected_points = 24 * 12  # 24 hours * 12 points per hour (5-minute intervals)
        actual_points = len(historical_data)
        
        return min((actual_points / expected_points) * 100, 100.0)
    
    def _generate_recommendations(self, stats: Dict, alert_history: List[Dict]) -> str:
        """Generate recommendations based on data analysis"""
        recommendations = []
        
        if not stats:
            return "- Continue monitoring\n- Ensure data collection systems are operational"
        
        # Analyze each gas
        for gas, gas_stats in stats.items():
            avg_level = gas_stats['mean']
            max_level = gas_stats['max']
            
            if gas == 'co2':
                if avg_level > 800:
                    recommendations.append(f"- **COâ‚‚ Reduction Urgent:** Average levels ({avg_level:.1f} ppm) exceed recommended limits. Consider improving ventilation or reducing emissions.")
                elif avg_level > 600:
                    recommendations.append(f"- **COâ‚‚ Monitoring:** Levels trending upward. Monitor closely and prepare mitigation measures.")
            
            elif gas == 'no2':
                if avg_level > 100:
                    recommendations.append(f"- **NOâ‚‚ Control Required:** Average levels ({avg_level:.1f} Âµg/mÂ³) exceed WHO guidelines. Implement NOx reduction technologies.")
                elif max_level > 150:
                    recommendations.append(f"- **NOâ‚‚ Peak Management:** Peak levels ({max_level:.1f} Âµg/mÂ³) indicate process optimization needed.")
            
            elif gas == 'so2':
                if avg_level > 50:
                    recommendations.append(f"- **SOâ‚‚ Mitigation:** Average levels ({avg_level:.1f} Âµg/mÂ³) require attention. Consider fuel switching or scrubbing technology.")
        
        # Alert-based recommendations
        if len(alert_history) > 5:
            recommendations.append("- **Alert Management:** High number of alerts today. Review operational procedures and emission control systems.")
        
        # General recommendations
        if not recommendations:
            recommendations.append("- **Maintain Current Operations:** Pollution levels within acceptable ranges.")
            recommendations.append("- **Preventive Maintenance:** Continue regular equipment maintenance schedule.")
        
        recommendations.append("- **Continuous Improvement:** Review daily trends and implement gradual improvements.")
        
        return '\n'.join(recommendations)
    
    def generate_shutdown_report(self, current_data: Dict, active_alerts: List[Dict]) -> str:
        """Generate emergency shutdown justification report"""
        report_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        
        report = f"""
# EMERGENCY SHUTDOWN RECOMMENDATION REPORT

**Generated:** {report_time}
**Status:** IMMEDIATE ACTION REQUIRED

---

## EXECUTIVE SUMMARY

Based on continuous monitoring data and persistent dangerous pollution levels, this report recommends **IMMEDIATE SHUTDOWN** of operations to protect public health and comply with environmental regulations.

## CURRENT POLLUTION LEVELS

"""
        
        for gas in ['co2', 'no2', 'so2']:
            if gas in current_data:
                level = current_data[gas]
                unit = 'ppm' if gas == 'co2' else 'Âµg/mÂ³'
                report += f"- **{gas.upper()}:** {level:.1f} {unit}\n"
        
        report += f"""
## ACTIVE ALERTS

**Total Critical Alerts:** {len([a for a in active_alerts if a.get('severity') == 'critical'])}
**Total Warning Alerts:** {len([a for a in active_alerts if a.get('severity') == 'warning'])}

### Alert Details:
"""
        
        for alert in active_alerts:
            report += f"""
#### {alert.get('gas', 'Unknown').upper()} Alert
- **Level:** {alert.get('level', 0):.1f}
- **Duration:** {alert.get('duration_minutes', 0):.1f} minutes
- **Severity:** {alert.get('severity', 'unknown').upper()}
- **Health Effects:** {', '.join(alert.get('health_effects', []))}
"""
        
        report += f"""
## REGULATORY COMPLIANCE

### Threshold Violations:
"""
        
        thresholds = {
            'co2': {'danger': 1000, 'unit': 'ppm'},
            'no2': {'danger': 200, 'unit': 'Âµg/mÂ³'},
            'so2': {'danger': 500, 'unit': 'Âµg/mÂ³'}
        }
        
        violations = []
        for gas, level in current_data.items():
            if gas in thresholds and level > thresholds[gas]['danger']:
                violations.append(f"- **{gas.upper()}:** {level:.1f} {thresholds[gas]['unit']} (Exceeds {thresholds[gas]['danger']} {thresholds[gas]['unit']} danger threshold)")
        
        if violations:
            report += '\n'.join(violations)
        else:
            report += "- No immediate threshold violations detected"
        
        report += f"""

## HEALTH RISK ASSESSMENT

### Immediate Health Risks:
"""
        
        health_risks = set()
        for alert in active_alerts:
            health_risks.update(alert.get('health_effects', []))
        
        for risk in health_risks:
            report += f"- {risk}\n"
        
        report += f"""
### Affected Populations:
- Factory workers and on-site personnel
- Nearby residential communities
- Sensitive groups (children, elderly, respiratory conditions)

## RECOMMENDED ACTIONS

### Immediate Actions (0-30 minutes):
1. **SHUTDOWN OPERATIONS** - Cease all emission-generating activities
2. **EVACUATE PERSONNEL** - Remove all non-essential personnel from affected areas
3. **ACTIVATE EMERGENCY PROTOCOLS** - Implement emergency response procedures
4. **NOTIFY AUTHORITIES** - Contact environmental regulatory agencies immediately
5. **MEDICAL STANDBY** - Ensure medical personnel are available for affected individuals

### Short-term Actions (1-24 hours):
1. **INVESTIGATE ROOT CAUSE** - Identify source of excessive emissions
2. **REPAIR/REPLACE EQUIPMENT** - Fix malfunctioning emission control systems
3. **ENVIRONMENTAL ASSESSMENT** - Conduct air quality measurements in surrounding areas
4. **STAKEHOLDER COMMUNICATION** - Inform employees, community, and media

### Long-term Actions (1-30 days):
1. **COMPREHENSIVE REVIEW** - Audit all emission control systems
2. **UPGRADE SYSTEMS** - Install additional pollution control equipment if needed
3. **TRAINING PROGRAM** - Retrain staff on emergency procedures
4. **MONITORING ENHANCEMENT** - Improve real-time monitoring capabilities

## LEGAL AND REGULATORY IMPLICATIONS

- **Environmental Protection Act** violations may result in fines up to $1M per day
- **Occupational Safety and Health** regulations require immediate worker protection
- **Community Right-to-Know** laws mandate public notification
- **Insurance Claims** may be affected by delayed response

## CONCLUSION

The persistent dangerous pollution levels documented in this report pose an **IMMEDIATE THREAT** to public health and environmental safety. Shutdown is not only recommended but **LEGALLY REQUIRED** under current environmental regulations.

**Authorized by:** ToxicGas AI Monitor System
**Report ID:** {datetime.now().strftime('%Y%m%d_%H%M%S')}_SHUTDOWN
**Distribution:** Environmental Manager, Plant Manager, Regulatory Affairs, Legal Department

---

*This report was automatically generated based on real-time monitoring data and regulatory compliance requirements.*
"""
        
        return report
    
    def send_email_report(self, report_content: str, recipients: List[str]) -> bool:
        """Send email report (placeholder implementation)"""
        try:
            # This is a placeholder implementation
            # In a real system, you would configure SMTP settings
            
            print(f"ğŸ“§ EMAIL REPORT SIMULATION")
            print(f"To: {', '.join(recipients)}")
            print(f"Subject: Daily Pollution Monitoring Report - {datetime.now().strftime('%Y-%m-%d')}")
            print(f"Content Length: {len(report_content)} characters")
            print("âœ… Email sent successfully (simulated)")
            
            # Log the email send
            self._log_email_send(recipients, "daily_report", True)
            
            return True
            
        except Exception as e:
            print(f"âŒ Failed to send email: {e}")
            self._log_email_send(recipients, "daily_report", False)
            return False
    
    def _log_email_send(self, recipients: List[str], report_type: str, success: bool):
        """Log email send attempts"""
        log_entry = {
            'timestamp': datetime.now().isoformat(),
            'recipients': recipients,
            'report_type': report_type,
            'success': success
        }
        
        # This would be saved to a log file in a real implementation
        print(f"ğŸ“ Email log: {log_entry}")
    
    def _save_report_to_history(self, report_content: str, report_date: str):
        """Save report to history file"""
        try:
            # Load existing history
            history = []
            if os.path.exists(self.report_history_file):
                with open(self.report_history_file, 'r') as f:
                    history = json.load(f)
            
            # Add new report
            history.append({
                'date': report_date,
                'timestamp': datetime.now().isoformat(),
                'content_length': len(report_content),
                'report_type': 'daily'
            })
            
            # Keep only last 30 days
            cutoff_date = datetime.now() - timedelta(days=30)
            history = [h for h in history if datetime.fromisoformat(h['timestamp']) > cutoff_date]
            
            # Save updated history
            with open(self.report_history_file, 'w') as f:
                json.dump(history, f, indent=2)
                
        except Exception as e:
            print(f"Error saving report history: {e}")
    
    def get_report_history(self) -> List[Dict]:
        """Get report generation history"""
        try:
            if os.path.exists(self.report_history_file):
                with open(self.report_history_file, 'r') as f:
                    return json.load(f)
        except:
            pass
        
        return []
    
    def generate_weekly_summary(self, weekly_data: pd.DataFrame) -> str:
        """Generate weekly summary report"""
        # This would generate a more comprehensive weekly analysis
        return "Weekly summary report (placeholder)"
    
    def generate_monthly_audit(self, monthly_data: pd.DataFrame) -> str:
        """Generate monthly audit report"""
        # This would generate a detailed monthly compliance audit
        return "Monthly audit report (placeholder)"
